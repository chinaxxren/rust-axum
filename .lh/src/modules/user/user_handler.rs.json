{
    "sourceFile": "src/modules/user/user_handler.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1730637012350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1730637018296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n \n use crate::{\n     modules::user::user_model::{LoginUserSchema, RegisterUserSchema, TokenClaims, User},\n     modules::user::user_response::FilteredUser,\n-    coAppState,\n+    common::app_stateAppState,\n };\n \n pub async fn health_checker_handler() -> impl IntoResponse {\n     const MESSAGE: &str = \"JWT Authentication in Rust using Axum, Postgres, and SQLX\";\n"
                },
                {
                    "date": 1730637559043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n \n use crate::{\n     modules::user::user_model::{LoginUserSchema, RegisterUserSchema, TokenClaims, User},\n     modules::user::user_response::FilteredUser,\n-    common::app_stateAppState,\n+    common::app_state::AppState,\n };\n \n pub async fn health_checker_handler() -> impl IntoResponse {\n     const MESSAGE: &str = \"JWT Authentication in Rust using Axum, Postgres, and SQLX\";\n@@ -74,9 +74,9 @@\n         body.name.to_string(),\n         body.email.to_string().to_ascii_lowercase(),\n         hashed_password\n     )\n-    .fetch_one(&data.db)\n+    .fetch_one(&data.db())\n     .await\n     .map_err(|e| {\n         let error_response = serde_json::json!({\n             \"status\": \"fail\",\n"
                },
                {
                    "date": 1730637612637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,9 +74,9 @@\n         body.name.to_string(),\n         body.email.to_string().to_ascii_lowercase(),\n         hashed_password\n     )\n-    .fetch_one(&data.db())\n+    .fetch_one(&data.db)\n     .await\n     .map_err(|e| {\n         let error_response = serde_json::json!({\n             \"status\": \"fail\",\n"
                },
                {
                    "date": 1730644132766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,11 +12,12 @@\n use rand_core::OsRng;\n use serde_json::json;\n \n use crate::{\n+    common::app_state::AppState,\n     modules::user::user_model::{LoginUserSchema, RegisterUserSchema, TokenClaims, User},\n     modules::user::user_response::FilteredUser,\n-    common::app_state::AppState,\n+    modules::user::user_dao,\n };\n \n pub async fn health_checker_handler() -> impl IntoResponse {\n     const MESSAGE: &str = \"JWT Authentication in Rust using Axum, Postgres, and SQLX\";\n@@ -32,20 +33,16 @@\n pub async fn register_user_handler(\n     State(data): State<Arc<AppState>>,\n     Json(body): Json<RegisterUserSchema>,\n ) -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {\n-    let user_exists: Option<bool> =\n-        sqlx::query_scalar(\"SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)\")\n-            .bind(body.email.to_owned().to_ascii_lowercase())\n-            .fetch_one(&data.db)\n-            .await\n-            .map_err(|e| {\n-                let error_response = serde_json::json!({\n+    let user_exists = user_dao::exists_user_by_email(&data, body.email).await\n+        .map_err(|e| {\n+            let error_response = serde_json::json!({\n                     \"status\": \"fail\",\n                     \"message\": format!(\"Database error: {}\", e),\n                 });\n-                (StatusCode::INTERNAL_SERVER_ERROR, Json(error_response))\n-            })?;\n+            (StatusCode::INTERNAL_SERVER_ERROR, Json(error_response))\n+        })?;\n \n     if let Some(exists) = user_exists {\n         if exists {\n             let error_response = serde_json::json!({\n@@ -67,18 +64,10 @@\n             (StatusCode::INTERNAL_SERVER_ERROR, Json(error_response))\n         })\n         .map(|hash| hash.to_string())?;\n \n-    let user = sqlx::query_as!(\n-        User,\n-        \"INSERT INTO users (name,email,password) VALUES ($1, $2, $3) RETURNING *\",\n-        body.name.to_string(),\n-        body.email.to_string().to_ascii_lowercase(),\n-        hashed_password\n-    )\n-    .fetch_one(&data.db)\n-    .await\n-    .map_err(|e| {\n+    let user = user_dao::save_user(&data, body.name.to_string(), body.email.to_string().to_ascii_lowercase(), hashed_password).await;\n+    user.map_err(|e| {\n         let error_response = serde_json::json!({\n             \"status\": \"fail\",\n             \"message\": format!(\"Database error: {}\", e),\n         });\n@@ -95,24 +84,19 @@\n pub async fn login_user_handler(\n     State(data): State<Arc<AppState>>,\n     Json(body): Json<LoginUserSchema>,\n ) -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {\n-    let user = sqlx::query_as!(\n-        User,\n-        \"SELECT * FROM users WHERE email = $1\",\n-        body.email.to_ascii_lowercase()\n-    )\n-    .fetch_optional(&data.db)\n-    .await\n-    .map_err(|e| {\n-        let error_response = serde_json::json!({\n+    let user = user_dao::find_user_by_email(&data, body.email).await;\n+    let user = user.map_err(|e| {\n+        let error_response = json!({\n             \"status\": \"error\",\n             \"message\": format!(\"Database error: {}\", e),\n         });\n         (StatusCode::INTERNAL_SERVER_ERROR, Json(error_response))\n-    })?\n-    .ok_or_else(|| {\n-        let error_response = serde_json::json!({\n+    })?;\n+\n+    let user = user.ok_or_else(|| {\n+        let error_response = json!({\n             \"status\": \"fail\",\n             \"message\": \"Invalid email or password\",\n         });\n         (StatusCode::BAD_REQUEST, Json(error_response))\n@@ -125,9 +109,9 @@\n         Err(_) => false,\n     };\n \n     if !is_valid {\n-        let error_response = serde_json::json!({\n+        let error_response = json!({\n             \"status\": \"fail\",\n             \"message\": \"Invalid email or password\"\n         });\n         return Err((StatusCode::BAD_REQUEST, Json(error_response)));\n@@ -145,10 +129,9 @@\n     let token = encode(\n         &Header::default(),\n         &claims,\n         &EncodingKey::from_secret(data.env.jwt_secret.as_ref()),\n-    )\n-    .unwrap();\n+    ).unwrap();\n \n     let cookie = Cookie::build(\"token\")\n         .path(\"/\")\n         .max_age(time::Duration::hours(1))\n@@ -156,11 +139,9 @@\n         .http_only(true)\n         .build();\n \n     let mut response = Response::new(json!({\"status\": \"success\", \"token\": token}).to_string());\n-    response\n-        .headers_mut()\n-        .insert(header::SET_COOKIE, cookie.to_string().parse().unwrap());\n+    response.headers_mut().insert(header::SET_COOKIE, cookie.to_string().parse().unwrap());\n     Ok(response)\n }\n \n pub async fn logout_handler() -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {\n"
                },
                {
                    "date": 1730644242830,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,9 +65,9 @@\n         })\n         .map(|hash| hash.to_string())?;\n \n     let user = user_dao::save_user(&data, body.name.to_string(), body.email.to_string().to_ascii_lowercase(), hashed_password).await;\n-    user.map_err(|e| {\n+    let user = user.map_err(|e| {\n         let error_response = serde_json::json!({\n             \"status\": \"fail\",\n             \"message\": format!(\"Database error: {}\", e),\n         });\n"
                }
            ],
            "date": 1730637012350,
            "name": "Commit-0",
            "content": "use std::sync::Arc;\n\nuse argon2::{password_hash::SaltString, Argon2, PasswordHash, PasswordHasher, PasswordVerifier};\nuse axum::{\n    extract::State,\n    http::{header, Response, StatusCode},\n    response::IntoResponse,\n    Extension, Json,\n};\nuse axum_extra::extract::cookie::{Cookie, SameSite};\nuse jsonwebtoken::{encode, EncodingKey, Header};\nuse rand_core::OsRng;\nuse serde_json::json;\n\nuse crate::{\n    modules::user::user_model::{LoginUserSchema, RegisterUserSchema, TokenClaims, User},\n    modules::user::user_response::FilteredUser,\n    coAppState,\n};\n\npub async fn health_checker_handler() -> impl IntoResponse {\n    const MESSAGE: &str = \"JWT Authentication in Rust using Axum, Postgres, and SQLX\";\n\n    let json_response = serde_json::json!({\n        \"status\": \"success\",\n        \"message\": MESSAGE\n    });\n\n    Json(json_response)\n}\n\npub async fn register_user_handler(\n    State(data): State<Arc<AppState>>,\n    Json(body): Json<RegisterUserSchema>,\n) -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {\n    let user_exists: Option<bool> =\n        sqlx::query_scalar(\"SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)\")\n            .bind(body.email.to_owned().to_ascii_lowercase())\n            .fetch_one(&data.db)\n            .await\n            .map_err(|e| {\n                let error_response = serde_json::json!({\n                    \"status\": \"fail\",\n                    \"message\": format!(\"Database error: {}\", e),\n                });\n                (StatusCode::INTERNAL_SERVER_ERROR, Json(error_response))\n            })?;\n\n    if let Some(exists) = user_exists {\n        if exists {\n            let error_response = serde_json::json!({\n                \"status\": \"fail\",\n                \"message\": \"User with that email already exists\",\n            });\n            return Err((StatusCode::CONFLICT, Json(error_response)));\n        }\n    }\n\n    let salt = SaltString::generate(&mut OsRng);\n    let hashed_password = Argon2::default()\n        .hash_password(body.password.as_bytes(), &salt)\n        .map_err(|e| {\n            let error_response = serde_json::json!({\n                \"status\": \"fail\",\n                \"message\": format!(\"Error while hashing password: {}\", e),\n            });\n            (StatusCode::INTERNAL_SERVER_ERROR, Json(error_response))\n        })\n        .map(|hash| hash.to_string())?;\n\n    let user = sqlx::query_as!(\n        User,\n        \"INSERT INTO users (name,email,password) VALUES ($1, $2, $3) RETURNING *\",\n        body.name.to_string(),\n        body.email.to_string().to_ascii_lowercase(),\n        hashed_password\n    )\n    .fetch_one(&data.db)\n    .await\n    .map_err(|e| {\n        let error_response = serde_json::json!({\n            \"status\": \"fail\",\n            \"message\": format!(\"Database error: {}\", e),\n        });\n        (StatusCode::INTERNAL_SERVER_ERROR, Json(error_response))\n    })?;\n\n    let user_response = serde_json::json!({\"status\": \"success\",\"data\": serde_json::json!({\n        \"user\": filter_user_record(&user)\n    })});\n\n    Ok(Json(user_response))\n}\n\npub async fn login_user_handler(\n    State(data): State<Arc<AppState>>,\n    Json(body): Json<LoginUserSchema>,\n) -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {\n    let user = sqlx::query_as!(\n        User,\n        \"SELECT * FROM users WHERE email = $1\",\n        body.email.to_ascii_lowercase()\n    )\n    .fetch_optional(&data.db)\n    .await\n    .map_err(|e| {\n        let error_response = serde_json::json!({\n            \"status\": \"error\",\n            \"message\": format!(\"Database error: {}\", e),\n        });\n        (StatusCode::INTERNAL_SERVER_ERROR, Json(error_response))\n    })?\n    .ok_or_else(|| {\n        let error_response = serde_json::json!({\n            \"status\": \"fail\",\n            \"message\": \"Invalid email or password\",\n        });\n        (StatusCode::BAD_REQUEST, Json(error_response))\n    })?;\n\n    let is_valid = match PasswordHash::new(&user.password) {\n        Ok(parsed_hash) => Argon2::default()\n            .verify_password(body.password.as_bytes(), &parsed_hash)\n            .map_or(false, |_| true),\n        Err(_) => false,\n    };\n\n    if !is_valid {\n        let error_response = serde_json::json!({\n            \"status\": \"fail\",\n            \"message\": \"Invalid email or password\"\n        });\n        return Err((StatusCode::BAD_REQUEST, Json(error_response)));\n    }\n\n    let now = chrono::Utc::now();\n    let iat = now.timestamp() as usize;\n    let exp = (now + chrono::Duration::minutes(60)).timestamp() as usize;\n    let claims: TokenClaims = TokenClaims {\n        sub: user.id.to_string(),\n        exp,\n        iat,\n    };\n\n    let token = encode(\n        &Header::default(),\n        &claims,\n        &EncodingKey::from_secret(data.env.jwt_secret.as_ref()),\n    )\n    .unwrap();\n\n    let cookie = Cookie::build(\"token\")\n        .path(\"/\")\n        .max_age(time::Duration::hours(1))\n        .same_site(SameSite::Lax)\n        .http_only(true)\n        .build();\n\n    let mut response = Response::new(json!({\"status\": \"success\", \"token\": token}).to_string());\n    response\n        .headers_mut()\n        .insert(header::SET_COOKIE, cookie.to_string().parse().unwrap());\n    Ok(response)\n}\n\npub async fn logout_handler() -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {\n    let cookie = Cookie::build(\"token\")\n        .path(\"/\")\n        .max_age(time::Duration::hours(-1))\n        .same_site(SameSite::Lax)\n        .http_only(true)\n        .build();\n\n    let mut response = Response::new(json!({\"status\": \"success\"}).to_string());\n    response\n        .headers_mut()\n        .insert(header::SET_COOKIE, cookie.to_string().parse().unwrap());\n    Ok(response)\n}\n\npub async fn get_me_handler(\n    Extension(user): Extension<User>,\n) -> Result<impl IntoResponse, (StatusCode, Json<serde_json::Value>)> {\n    let json_response = serde_json::json!({\n        \"status\":  \"success\",\n        \"data\": serde_json::json!({\n            \"user\": filter_user_record(&user)\n        })\n    });\n\n    Ok(Json(json_response))\n}\n\nfn filter_user_record(user: &User) -> FilteredUser {\n    FilteredUser {\n        id: user.id.to_string(),\n        email: user.email.to_owned(),\n        name: user.name.to_owned(),\n        photo: user.photo.to_owned(),\n        role: user.role.to_owned(),\n        verified: user.verified,\n        createdAt: user.created_at.unwrap(),\n        updatedAt: user.updated_at.unwrap(),\n    }\n}\n"
        }
    ]
}